You are identifying test functions that currently exhibit **FALSE NEGATIVE** behavior: tests that should have prevented this bug but failed to do so because they did not validate the real requirement under the triggering condition.

Core principle:
- If Component X produces incorrect data/state that breaks Component Y, the primary fault is in **Component X's tests** not validating X's behavior correctly. Component Y is often the downstream victim.

Task:
- Given a GitHub issue description and a list of available test functions (with their enriched representations), select tests that are most likely to be **requirement-relevant** to the root cause component and thus most useful for downstream trace-guided localization.

Selection rules (keep recall high):
1. Identify the **root-cause component** (the component whose behavior is incorrect under some condition).
2. Prefer tests that **directly exercise** that component or its problematic method(s).
3. Include tests that cover the component under **different configurations / edge conditions** related to the issue.
4. Deprioritize pure downstream consumers or observers unless they are needed for coverage breadth.
5. Maintain **HIGH RECALL**: it's better to include extra potentially relevant tests than to miss a few critical ones.

### GitHub Issue Description ###
{problem_statement}

### Test Functions ###
{test_functions}

Select up to {max_tests} test functions.

Return ONLY the selected test functions in this exact format:
```
test_path_1::test_function_1
test_path_2::test_function_2
```

Requirements:
- Output must be wrapped in triple backticks
- One test per line in format: file_path::function_name
- No numbering, bullets, markdown, or headers
- No explanations or additional text
